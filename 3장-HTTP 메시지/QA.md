# 질의응답
## (찬규) 상태코드 100이 사용되는 다른 예시
- 정보를 처리하는 중임을 알리는데 사용
- 100 - Continue
  - 클라이언트가 데이터를 전송하기 전에 서버의 준비 상태를 확인하는 경우
- 101 - Switching Protocols
  - 클라이언트가 프로토콜 전환을 요청하고 서버가 이를 수락할 때
- 102 - Processing
  - 서버가 요청을 처리하는데 시간이 걸릴 때, 클라이언트에게 진행 상태를 알리기 위해

### 🧐 102 Processing이 타임아웃을 방지해주는 것?
* 그렇다고 볼 수 있음
* 허나 이제는 더이상 쓰이지 않음

### 🧐 101 Switching Protocols 에서 프로토콜이 어떤 것?
* HTTP, HTTPS 이런 유형
* HTTP/1.0 -> HTTP/2.0 이런 전환을 요청하는 것인지? 사실 일반적으로 바꿀 이유는 없지 않나?
* 웹소켓으로 업그레이드 요청하고 그럴때 사용할 수 있을 것 같음

<br/>

## (찬규) 상태코드와 사유 구절이 1:1로 매칭되어야 하는 이유
- 사유 구절이 같으면 다른 상태코드로 분기될 이유 없음
- 표준화된 명세에 애초에 1:1로 대응됨 → 명세에 따라 상태코드를 분기한다면 사유 구절도 그것에 1:1로 매칭됨

### 🧐 사유 구절이 명확한 정답이 있는건 아니지 않나? 
- `엄격한 사유 구절 규칙이 정해져있지 않다`는 때문에 어떤 규격을 갖지 않는다고 생각함
  <br/> -> 상태코드가 명확한 약속이기 때문에 사유구절에도 어느 정도 암묵적 룰이 있으리라 생각함

### 🧐 404의 사유구절은 NOT FOUND 로 거의 고정인데 뒤에 추가적으로 메세지를 더하는 건 괜찮지 않나?
- 그런 추가적인 정보 전달은 Response Body 를 이용하면 될 것 같음

### 🧐 항상 이렇게 상태코드를 세부적으로 하는게 맞는건가?
- 200, 404 이렇게 둘만 있다고 생각하면 소통하는데도 한계가 있을듯. 지금 프론트에선 500 Internal Server Error 만 와도 알 수 있는 정보가 많이 없어서 답답한 경우가 있는 것처럼 이 정돈 지켜줘도 좋을듯
- 403 같이 정말 유용하게 쓰이는 상태코드 정도는 많이 유용하게 쓰이고 있으니 잘 활용하면 좋을듯

### 🆕 어떤 기업 API 에서 같은 200인데, 다른 분기로 보내는 경우도 있었음

<br/>

## (찬규) DELETE 메서드는 왜 클라이언트에게 요청에 대한 결과를 알리지 않아도 되게 명세되었을까?
- 응답에 본문이 없다는 것이 성공(리소스가 이제 존재하지 않아야 한다는)에 대한 간접적인 피드백임(해당 리소스가 삭제되었든 애초에 없던 리소스든)
- 삭제되었는지 삭제되지 않았는지에 대한 정보 대신에 해당 리소스가 존재하는지 아닌지에 대해 204 No Content로 대응함으로 동일한 시도에 대한 동일한 결과를 보장함

<br/>

## (민지) Expect 헤더란?
- 요청을 적절하게 처리하기 위해 서버가 반환할 기대값을 나타내는 것
- Expect: 100-continue 이 유일한 명세에 정의된 값으로 서버는 이에 대해 성공을 의미하는 100과 실패를 의미하는 417 로 응답함

<br/>

## (연진) 프락시는 어떤 역할을 하는 것일까?
인터넷 속도를 개선하기 위해 고속 데이터 통신이 가능한 건물 내부에 캐시를 두는데, 그 캐시 역할을 하는 것이 바로 프록시 서버이다.
- 병목현상 방지
  프록시는 요청받은 데이터를 캐시에 저장해두고, 캐시에 저장된 데이터 요청에 대해서는 실제 서버에 요청하지 않고 직접 응답한다. 이로써 데이터 전송시간과 불필요한 트래픽 발생을 줄어들어 서버측의 네트워크 병목현상을 방지할 수 있다.
- 보안유지
  회사 및 중요기관에서 프록시 서버를 통해 내부 통신과 외부 데이터 접근을 통제하여 보안 유지를 한다.
  또한 프록시 서버에는 로그가 남기 때문에 인터넷 이용률 통계를 수집하여 분석하는 데 프록시 서버를 사용한다.
(프록시 서버를 경유한다고 해도 IP 추적이 가능하지만,
IP 추적 비용 > IP 사용자에게 청구해서 얻는 이익 의 경우가 대부분이라 추적을 안 하는 것이라고 한다.)

<br/>

## (연진) 캐리지 리턴이 무엇일까
문자의 새 줄을 시작하는 데 쓰이는 제어 문자나 그 구조
- \r
  Carriage Return(CR) 라는 의미를 가지며 일반적으로는 맨앞으로 이동하라는 의미
- \n
  Line Feed(LF) 라는 의미를 가지며 일반적으로는 New Line, 즉 새로운 라인이라는 의미

### 🆕 캐리지 리턴이 원래 타자기에 있던 개념이었음
- 타자기의 구조나 레버를 가리키는 용어였다고 함

<br/>

## (해찬) 메서드를 선택하는 기준
1. GET vs POST (Ex. 로그인)<br/>
    - GET: 보안성 X. 파라미터, 쿼리스트링이 외부로 노출된다. 단순 정보 반환 용도.<br/>
    - POST: HTTPS 사용시 데이터 암호화.

2. POST vs PUT<br/>
    - POST: 멱등성 X. 통신이 실패했을 때 자동 재시도하면 안된다. (서버가 어느 작업까지 완료했는지 알 수 없음)<br/>
    - PUT: 멱등성 O. 한번 호출하든, 여러번 호출하든 서버에 미치는 영향은 똑같다.

<br/>

## (해찬) PUT, DELETE 등의 메서드를 써도 될까?
- 상황
    1. 웹 브라우저 중에서 GET, POST만 지원하는 경우가 있다.<br/>
    2. 정부기관에서 보안상의 이유로 사용하지 않을 PATCH, DELETE 등의 메서드를 금지하는 경우가 있다.

- 해결
    1. RESTful API를 개발하려면 PATCH, DELETE 등의 메서드를 사용할 수 밖에 없다. RESTful의 가독성과 보안성 중에서 선택해야 할듯 하다.<br/>
    2. 웹 브라우저가 지원하지 않는 메서드는 [추가적인 처리](https://velog.io/@ette9844/REST-PUT-PATCH-DELETE-미지원-처리)를 통해 서버에서 처리할 수 있는 듯하다.<br/><br/>

### 🧐 그래서 둘 중 어떤게 좋다고 생각해?
- 쓰는 걸 좀더 선호하긴 하나, 못 쓰는 상황을 염두에 두기

### 🧐 메소드 이름만 바꾼다고 해결되는 문제인가?
- 애초에 PATCH, DELETE 가 보안적인 문제가 있다면 POST 라고 안전하다는 보장이 없지 않나?
- GET, POST 가 주로 사용되고 DELETE, PUT 은 자주 사용하지 않다보니, 서버 관리자가 GET, POST 에 대해서만 보안설정을 하는경우가 많아서 그런 이야기가 나왔다는 카더라가 있음
- CSRF (Cross-Site Request Forgery): 악의적인 웹사이트가 사용자를 속여 특정 웹 애플리케이션에 PATCH 또는 DELETE 요청을 보내게 할 수 있고 이는 사용자가 의도하지 않은 데이터 변경 또는 삭제를 초래할 수 있음. 따라서 사용자가 로그인된 상태에서 악의적인 웹사이트를 방문했을 때 PATCH, DELETE 요청을 전송할 수 있음
<br/>그렇다면 CSRF 상황에서 함부로 리소스를 삭제시켜버릴 수 있기 때문에 보안적 이슈가 있다고 생각한 게 아닐까?


## (해찬) 포스텔의 법칙?
- 엄격하게 보내고 관대하게 받아들여라.<br/>
  -> 요구사항을 최소화하라는 의미일까?<br/>
  -> 최대한 하위 호환성을 잘 지켜주고, 보낼 때는 다른 HTTP 에 쓰이지 않는 요소나, 오해해서 쓸 수 있는 요소들을 지양하라는 이야기라고 생각했음 
- UX에 많이 사용되는 듯. 사용자 입력을 최소한으로 받아야 하고, 입력되지 않은 값은 안내를 통해 입력을 유도하는 등.<br/>
- 생각나는 예시는 서버 응답에 null 값이 포함된 경우 이를 처리하는 정도.<br/><br/>